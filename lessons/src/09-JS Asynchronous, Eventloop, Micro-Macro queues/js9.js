// event-loop

/*Стек в JavaScript — это структура данных, работающая по принципу LIFO (последним пришёл, первым ушёл).
Элементы добавляются и удаляются с одного конца — вершины стека.*/

/*Очередь — это структура данных FIFO (первым пришёл, первым вышел).
Элементы добавляются в конец и удаляются из начала.*/

/*Macrotasks (Макрозадачи) 3
Макрозадачи — это задачи, которые обрабатываются в рамках одного итеративного цикла (event loop).
После завершения каждой макрозадачи происходит переход к следующему циклу. Примеры макрозадач:
setTimeout
setInterval
Обработчики событий (например, click, scroll)
Запросы через XMLHttpRequest или fetch
*/

/*Microtasks (Микрозадачи) 1
Микрозадачи выполняются сразу после текущей макрозадачи, но перед началом следующей макрозадачи.
Их выполнение происходит в том же цикле событий, но с более высоким приоритетом. Примеры микрозадач:
Promise (методы then, catch, finally)
MutationObserver
Очередь микрозадач, созданная с помощью метода queueMicrotask
*/

/*Rendering Tasks (Задачи рендеринга) 2
Задачи рендеринга связаны с обновлением интерфейса, таким как перерисовка или перекомпоновка элементов на странице.
Рендеринг обычно происходит после выполнения всех микрозадач, но до начала новой макрозадачи. Примеры:
Пересчет стилей (recalculate style)
Перерисовка (paint)
Компоновка (layout)
Композиция (compositing)
*/

// Задача 1
/*console.log('start')

setTimeout(function () {
    console.log('timeout')
}, 1000)

console.log('end')*/

// Задача 2
/*function a() {
    setTimeout(() => {  // Макрозадача: добавляется в очередь макрозадач
        console.log('a')  // Будет выполнено после всех микрозадач и синхронного кода
    }, 0);
}

function b() {
    console.log('b');  // Синхронный код: выполняется сразу
}

a();  // Вызываем функцию `a`, которая добавляет макрозадачу
new Promise(function (res, rej) {  // Синхронный код: выполняется сразу
    console.log('create promise');  // Синхронный код: выводится сразу
    res();  // Промис разрешается, добавляет микрозадачу `.then`
}).then(() => {  // Микрозадача: будет выполнена после всего синхронного кода
    setTimeout(function timer() {  // Макрозадача: добавляется в очередь макрозадач
        console.log('timeout');  // Будет выполнено после всех микрозадач и других макрозадач
    }, 0);
});
b();  // Вызываем функцию `b`, которая сразу выводит 'b'*/

/*
   'create promise'
   'b'
   'a'
   'timeout'
*/

// Задача 4
/*setTimeout(() => {
    console.log("1");
}, 0); // Помещается в очередь макрозадач, будет выполнен после всех микрозадач.
setTimeout(() => {
    console.log("2");
}, 1000); // Также помещается в очередь макрозадач, но с задержкой 1000мс.
new Promise(function (res, rej) {
    console.log("3"); // Синхронный код, выполняется сразу.
    res();
    console.log("4"); // Синхронный код, выполняется сразу.
}).then(() => {
    console.log("5"); // Помещается в очередь микрозадач, будет выполнено после всего синхронного кода.
});
console.log("6"); // Синхронный код, выполняется сразу.
async function test1() {
    console.log("7"); // Синхронный код, выполняется сразу.
    await test2(); // Вызов test2 синхронный, но после await управление передается, и дальнейший код помещается в микрозадачу.
    console.log("8"); // Будет выполнен как микрозадача после завершения текущих микрозадач (т.е. после then).
}

async function test2() {
    console.log("9"); // Синхронный код, выполняется сразу.
}

test1(); // Вызов функции test1, выполняется синхронно.
console.log("10"); // Синхронный код, выполняется сразу.*/

// Задача 5
/*
console.log(1);
setTimeout(() => {
    console.log(2); // Помещается в очередь макрозадач.
    Promise.resolve()
        .then(() => {
            console.log(3); // Вставляется в очередь микрозадач после выполнения макрозадачи (2).
        });
});
new Promise((res, rej) => {
    console.log(4); // Синхронный код, выполняется сразу.
    res(5);
})
    .then((data) => {
        console.log(data); // Микрозадача, выполняется после всего синхронного кода.
        Promise.resolve()
            .then(() => {
                console.log(6); // Микрозадача, выполняется после вывода 5.
            })
            .then(() => {
                console.log(7); // Микрозадача, выполняется после вывода 6.
                setTimeout(() => {
                    console.log(8); // Помещается в очередь макрозадач.
                }, 0);
            });
    });
setTimeout(() => {
    console.log(9); // Помещается в очередь макрозадач.
});
console.log(10);
*/

// Задача 6
/*
async function first() {
    console.log(9);  // Синхронный код, выполняется сразу.
    await Promise.resolve(2)
        .then((r) => console.log(r));  // Преобразуется в микрозадачу, будет выполнено после текущих синхронных задач.
    console.log(0);  // В микрозадаче после выполнения предыдущей await.
    await Promise.resolve(3)
        .then((r) => console.log(r));  // Преобразуется в микрозадачу, выполняется после предыдущих.
}

async function second() {
    console.log(10);  // Синхронный код, выполняется сразу.
    await Promise.resolve(4)
        .then((r) => console.log(r));  // Преобразуется в микрозадачу, будет выполнено после текущих синхронных задач.
    console.log(11);  // В микрозадаче после выполнения предыдущей await.
    await Promise.resolve(5)
        .then((r) => console.log(r));  // Преобразуется в микрозадачу, выполняется после предыдущих.
}

first();
second();

const promises = Promise.resolve("new Promise");
promises.then((str) => console.log(str));  // Преобразуется в микрозадачу.*/
